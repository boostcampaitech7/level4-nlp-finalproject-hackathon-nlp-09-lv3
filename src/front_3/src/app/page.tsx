"use client";

import { useState, useRef, Dispatch, SetStateAction } from "react";
import { useClosedQueryApi } from "./store/useClosedQueryApi";// API ÌõÖ ÏûÑÌè¨Ìä∏
import { useOpenQueryApi } from "./store/useOpenQueryApi";// API ÌõÖ ÏûÑÌè¨Ìä∏
import { useQueryApi } from "./store/useQueryApi";
//import { closedQueryClient } from "./store/closedQueryClient";// API ÌõÖ ÏûÑÌè¨Ìä∏
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import ExampleList from "./components/ExampleList";
import SearchBar from "./components/SearchBar";
import ChatList from "./components/ChatList";
import ThemeToggle from "./components/ThemeToggle";
import ChatHistoryMenu from './components/ChatHistoryMenu';
import type { ChatHistory } from './types/chatHistory';
import { parseClosedApiResponse } from './api/parsers/chatParser';
import type { QAndA } from "./types/question";

export const closedQueryClient = new QueryClient();

function HomeContent() {
  const [questionList, setQuestionList] = useState<QAndA[]>([]);
  const [showExampleList, setShowExampleList] = useState(true);
  const [histories, setHistories] = useState<ChatHistory[]>([]);
  const [domain, setDomain] = useState<'open' | 'close' | null>(null);
  const [currentChatId, setCurrentChatId] = useState<string | null>(null);
  const [loadingIndex, setLoadingIndex] = useState<number | null>(null);
  const [loading, setLoading] = useState(false);
  
  const searchBarRef = useRef<{ setText: (text: string) => void } | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);
  const { mutate: mutateClosed, isPending: isPendingClosed, mutateAsync: mutateAsyncClosed } = useClosedQueryApi();
  const { isPending: isPendingOpen, mutateAsync: mutateAsyncOpen } = useOpenQueryApi();
  const { isPending: isPendingQuery, mutateAsync: mutateAsyncQuery } = useQueryApi();
  

  const handleExampleClick = (example: string) => {
    setShowExampleList(false);  // ÏòàÏãú ÏßàÎ¨∏ ÌÅ¥Î¶≠ ÏãúÏóêÎèÑ Î™©Î°ù Ïà®ÍπÄ
    const formData = new FormData();
    formData.append('search', example);
    handleSubmit(formData);
  };

  const handleSubmit = async (formData: FormData) => {
    const submittedQuestion = formData.get("search") as string;
    
    if (!submittedQuestion?.trim()) return;


    // ÏòàÏãú ÏßàÎ¨∏ Î™©Î°ùÏùÑ Í∞ïÏ†úÎ°ú Ïà®ÍπÄ
    setShowExampleList(false);

    // ÏûÖÎ†• ÌïÑÎìú Ï¥àÍ∏∞Ìôî
    if (searchBarRef.current) {
      searchBarRef.current.setText('');
    }

    const newQuestion = {
      question: submittedQuestion,
      answer: null,
    };


    // ÏÉà ÏßàÎ¨∏ÏùÑ Ìïú Î≤àÎßå Ï∂îÍ∞Ä
    const updatedQuestionList = [...questionList, newQuestion];
    setQuestionList(updatedQuestionList);

    if (!currentChatId) {
      const newId = Date.now().toString();
      setCurrentChatId(newId);
      const newHistory: ChatHistory = {
        id: newId,
        title: submittedQuestion,
        messages: [newQuestion],
        createdAt: new Date(),
      };
      setHistories(prev => [newHistory, ...prev]);
    } else {
      updateCurrentChat(updatedQuestionList);
    }


    setLoadingIndex(questionList.length);
    try {
      let result;
    
      // domainÏóê Îî∞Îùº Îã§Î•∏ APIÎ•º Ìò∏Ï∂ú
      if (domain === null) {
        result = await mutateAsyncQuery(submittedQuestion); // query API Ìò∏Ï∂ú
        console.log("query API ÏùëÎãµ Í≤∞Í≥º:", result);
      } else if (domain === 'close') {
        result = await mutateAsyncClosed(submittedQuestion); // closed API Ìò∏Ï∂ú
        console.log("closed API ÏùëÎãµ Í≤∞Í≥º:", result);
      } else if (domain === 'open') {
        result = await mutateAsyncOpen(submittedQuestion); // open API Ìò∏Ï∂ú
        console.log("open API ÏùëÎãµ Í≤∞Í≥º:", result);
      }

      // üîπ API ÏùëÎãµÏùÑ parseClosedApiResponseÎ°ú Î≥ÄÌôò
      const parsedResponse = parseClosedApiResponse(result, submittedQuestion);

      // ÏÉàÎ°úÏö¥ ÏßàÎ¨∏ Í∞ùÏ≤¥ ÏóÖÎç∞Ïù¥Ìä∏
      const updatedQuestion = {
        ...newQuestion,
        answer: parsedResponse.answer,
        error: false,
        imageName: parsedResponse.imageName, // Ïù¥ÎØ∏ÏßÄ Ï†ïÎ≥¥
        fileNames: parsedResponse.fileNames,  // PDF Ï†ïÎ≥¥
        audioFileName: parsedResponse.audioFileName, // TTS Ïò§ÎîîÏò§ ÌååÏùº Ï†ïÎ≥¥ // Ï∂úÏ≤ò Ï†ïÎ≥¥ Ï∂îÍ∞Ä
        visualized_name: parsedResponse.visualized_name,
      };

      // ÎßàÏßÄÎßâ ÏßàÎ¨∏Îßå ÏóÖÎç∞Ïù¥Ìä∏
      setQuestionList(prev => prev.map((q, i) => 
        i === prev.length - 1 ? updatedQuestion : q
      ));

      if (currentChatId) {
        const finalQuestionList = questionList.map((q, i) => 
          i === questionList.length - 1 ? updatedQuestion : q
        );
        updateCurrentChat(finalQuestionList);
      }

    } catch (error) {
      console.error("API ÏöîÏ≤≠ Ïã§Ìå®:", error);
      const errorQuestion = {
        ...newQuestion,
        error: true
      };
      setQuestionList(prev => prev.map((q, i) => 
        i === prev.length - 1 ? errorQuestion : q
      ));
    } finally {
      setLoadingIndex(null);
    }
  };

  // ÏÉàÎ°úÏö¥ ÎåÄÌôî ÏãúÏûë Ïãú ÌòÑÏû¨ ÎåÄÌôî Ï†ÄÏû•
  const saveCurrentChat = () => {
    if (questionList.length > 0) {
      // ÌòÑÏû¨ ÎåÄÌôîÍ∞Ä Ïù¥ÎØ∏ Ï†ÄÏû•ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      const isAlreadySaved = histories.some(history => 
        history.messages.length === questionList.length && 
        history.messages[0].question === questionList[0].question &&
        history.messages[history.messages.length - 1].question === 
        questionList[questionList.length - 1].question
      );

      if (!isAlreadySaved) {
        const newHistory: ChatHistory = {
          id: Date.now().toString(),
          title: questionList[0].question,
          messages: [...questionList],
          createdAt: new Date(),
        };
        setHistories(prev => [newHistory, ...prev]);
      }
    }
  };

  // ÏÉàÎ°úÏö¥ ÎåÄÌôî ÏãúÏûë
  const handleNewChat = () => {
    if (currentChatId) {
      saveCurrentChat();
    }
    setCurrentChatId(null);
    setQuestionList([]);
    setShowExampleList(true);
  };

  // Ï†ÄÏû•Îêú ÎåÄÌôî ÏÑ†ÌÉù
  const handleSelectHistory = (history: ChatHistory) => {
    if (currentChatId && currentChatId !== history.id) {
      saveCurrentChat();
    }
    setCurrentChatId(history.id);
    setQuestionList(history.messages);
    setShowExampleList(false);
  };

  // ÎåÄÌôî ÎÇ¥Ïö©Ïù¥ ÏóÖÎç∞Ïù¥Ìä∏Îê† ÎïåÎßàÎã§ histories ÏóÖÎç∞Ïù¥Ìä∏
  const updateCurrentChat = (newQuestionList: QAndA[]) => {
    if (currentChatId) {
      setHistories(prev => prev.map(history => 
        history.id === currentChatId
          ? {
              ...history,
              messages: newQuestionList,
              // ÎßàÏßÄÎßâ Î©îÏãúÏßÄÍ∞Ä Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞ÏóêÎßå title ÏóÖÎç∞Ïù¥Ìä∏
              title: history.messages[0].question
            }
          : history
      ));
    }
  };

  const handleAbort = () => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
  };

  //Ïû¨ÏãúÎèÑ Î°úÏßÅ
  const handleRetry = async (index: number) => {
    const question = questionList[index].question;
    // if (!question) return;
    
    // setLoadingIndex(index);

    // try {
    //   const result = await mutation.mutateAsync({ query: question });
      
    //   const updatedList = questionList.map((qa, i) => 
    //     i === index 
    //       ? { 
    //           ...qa, 
    //           answer: result.answer, 
    //           context: result.context,
    //           imageNames: result.imageNames,
    //           fileNames: result.filenames,
    //           error: false 
    //         } 
    //       : qa
    //   );
      
    //   setQuestionList(updatedList);
    //   if (currentChatId) {
    //     updateCurrentChat(updatedList);
    //   }
    // } catch (error) {
    //   console.error("API ÏöîÏ≤≠ Ïã§Ìå®:", error);
    //   const updatedList = questionList.map((qa, i) => 
    //     i === index 
    //       ? { ...qa, error: true } 
    //       : qa
    //   );
    //   setQuestionList(updatedList);
    //   if (currentChatId) {
    //     updateCurrentChat(updatedList);
    //   }
    // } finally {
    //   setLoadingIndex(null);
    // }
  };

  // ÎåÄÌôî ÏÇ≠Ï†ú Ìï∏Îì§Îü¨
  const handleDeleteHistory = (id: string) => {
    setHistories(prev => prev.filter(history => history.id !== id));
    if (currentChatId === id) {
      setCurrentChatId(null);
      setQuestionList([]);
      setShowExampleList(true);
    }
  };

  return (
    <div className="flex flex-col min-h-screen bg-[var(--background)]">
      <ThemeToggle />
      <ChatHistoryMenu
        histories={histories}
        onSelectHistory={handleSelectHistory}
        onDeleteHistory={handleDeleteHistory}
        onNewChat={handleNewChat}
      />

      <div className="flex-1 flex flex-col overflow-y-auto">
        {questionList.length > 0 ? (
          <ChatList 
            questionList={questionList} 
            onRetry={handleRetry}
            isLoading={domain === 'close' ? isPendingClosed : 
                      domain === 'open' ? isPendingOpen : 
                      isPendingQuery}
            loadingIndex={loadingIndex}
          />
        ) : showExampleList ? (
          <div className="flex-1 flex items-center justify-center">
            <ExampleList onExampleClick={handleExampleClick} />
          </div>
        ) : null}
      </div>

      <div className="w-full max-w-4xl mx-auto px-4">
        <SearchBar 
          ref={searchBarRef}
          handleSubmit={handleSubmit}
          domain={domain}
          setDomain={setDomain}
          isLoading={domain === 'close' ? isPendingClosed : 
                    domain === 'open' ? isPendingOpen : 
                    isPendingQuery}
          setLoading={setLoading}
          onAbort={handleAbort}
        />
      </div>
    </div>
  );
}

export default function Home() {
  return (
    <QueryClientProvider client={closedQueryClient}>
      <HomeContent />
    </QueryClientProvider>
  );
}